---
layout: post
title: 密码学，从入门到劝退：古典密码（上篇）
date: 2020-12-24 15:37
category: cryptography
keywords: cryptography
preview: 1
---

# 其之二 推古及今：古典密码与现代密码

与其他很多学科不同的是，始于70年代的现代密码学，并非是在古典密码学上平缓发展而来的学科，而是一次开天辟地式的飞跃。之所以说是“开天辟地式”，是因为我们直到那时候才开始真正体系化地运用数学手段对密码学建模。密码学的这个飞跃大概可以说是到来得惊人地晚。

而若以现代密码学的眼光回首望去，在这之前的古典密码学时代（哪怕是不到一百年前的20世纪初期），相比之下可谓是茹毛饮血——那时候的攻防手段基本还是基于语言文本的分析，而非如现代密码学一般基于信息论、离散概率以及其他数学手段。因为没有衡量安全性的手段，古典密码学里自然也无从对加密算法进行数学层面上的安全分析，加解密攻防不可避免地变成了猫鼠游戏式的勾心斗角。

但即便如此，认真回顾这个持续了数千年的古典时代也是极有价值的。以史为鉴，将能让我们更为清晰地认知到加密算法所面对的威胁，以及现代密码学所提供的数学手段的宝贵。

因此，虽说有老生常谈之嫌，本文仍将迅速地带领读者过一遍几种典型的古典密码。

<!--more-->

# 其之二甲 以史为鉴：古典密码（上篇）

## 一点背景知识：术语科普

名不正则言不顺。在正式进行古典密码的科普之前，我们需要先储备点基础的密码学术语。

- 密码（Cipher）：进行加密或解密的算法。注意此语境下的密码为 Cipher 的翻译，而非通常汉语口语中由用户输入的 Password。
- 密钥（Key）：一串保密信息，用于指导密码（Cipher）对原文及密文进行变换。
- 明文（Plaintext）：未经加密的原始消息。
- 密文（Ciphertext）：明文经加密算法变换后的产物。
- COA，惟密文攻击（Ciphertext only Attack）：最严格的攻击模型。假定攻击者只能获得加密后的密文。此时攻击者的目标通常是获得明文，以及密钥；但在特定情况下，即使攻击者无法获得完整的明文，只要能得到关于明文的更多信息，也可算作成功。
- KPA，已知明文攻击（Known Plaintext Attack）：假定攻击者能够获得明文和与之对应的密文的攻击模型。此时攻击者的目标通常是获得密钥。
- CPA，选中明文攻击（Chosen Plaintext Attack）：假定攻击者能够自选任意明文，并获得对应密文的攻击模型。此时攻击者的目标通常是获得密钥。
- CCA，选中密文攻击（Chosen Ciphertext Attack）：假定攻击者能够自选任意明文，并获得对应解密后的明文的攻击模型。此时攻击者的目标通常是获得密钥。

注意以上名词并非局限于古典密码学——不如说这些名词在现代密码学里会被更广泛地应用。

在明确词义之后，我们终于可以开始讨论古典密码了。而最适合打头阵的，当然是替换密码。

## 替换密码

谈到“密码”二字，绝大部分人的第一反应恐怕都是替换密码。这东西原理很简单：设定一张替换表，其中每一个字母都会被一一映射到另一个字母上；加密时将明文中每一个字符按照映射替换成对应的字母，解密则只是简单地逆向映射。

顺嘴一提，我们可以将这个映射表看作密钥，只要能得到它，攻击便宣告成功。

这东西安全度如何呢？按照我们上面提到的四种攻击模型分别讨论一下：

CPA 以及 CCA：显然，无论我们手里的神谕机（Oracle）是加密神谕还是解密神谕，我们都只需要把所有字母灌进去，立刻就可以得到完整的映射表，不费吹灰之力。

KPA：取决于能够获得的明文长度，以及明文中不同字母的种类，我们至少能获得映射表的一部分。对于那些字母表不大的语言来说，恐怕不需要多长的明文就足够我们推出整张映射表。

COA：这里需要我们稍微动点脑筋。假设明文的语言已知的话，我们可以采用一点统计手段：大部分自然语言的字母出现概率并不随机。以英语为例，e 出现的概率会是最高的，所以只需要统计出密文中出现概率最高的字母，我们便可以大概率确定它与 e 互相对应。其他字母也可以根据明文的语言特征分析出来。具体的例子因为过于经典已经在各种密码学教程中烂大街了，在这里我不再赘述。

显然，替换密码的安全度并不高。

## 凯撒密码及其变体

严格来说，凯撒密码其实是更弱一些的替换密码，所以对于替换密码的攻击只会对凯撒密码更有效。不过鉴于凯撒密码实际上我们之后将要介绍的不少其他密码的基础构造之一，这里我还是把它单独拎出来讲一下。

凯撒密码的构造更为简单：将明文的每个字符按字母表顺序后移三位，即可得到密文。但仅仅如此的话，凯撒密码本身并不足以成为我们所讨论的密码（Cipher）：它没有密钥。这也是为什么本节的标题强调了“及其变体”：我们可以将这个构造略微扩展，令原本的后移三位变为后移 k 位，此时这里的 k 便可被视作密钥。

显然，要破解凯撒密码，我们只需要推出 k；而要推出 k，只需要推断出明文中任意一个字母于密文中所对应的字母，二者的距离即为 k。鉴于其本质仍是替换密码，运用针对替换密码的攻击手段推出密钥轻而易举。

能否对这个构造略微修改，使得它变得更加安全呢？

## 维吉尼亚密码

一点花边：维吉尼亚密码的名称来源于 Blaise de Vigenère(1523-1596)，但现今已知的对该密码的最早论述实际由 Giovan Battista Bellaso 于1553给出。

以英语为例，我先简单介绍一下维吉尼亚密码：

维吉尼亚密码的密钥是一个单词（或者说，一串固定长度的文本）。这里我们先选用一个充满酸味的密钥，"LEMON"。

给出一段任意长度的文本，我们先将明文字母和密钥对齐地写在上下两行。若密钥长度不足，则循环密钥补齐。例如，若我们需要加密 "ATTACKATDAWN":

<pre>
明文 ATTACKATDAWN
密钥 LEMONLEMONLE
密文
</pre>

然后，我们将明文中的每一个字母循环后移“密钥中对应字母的序数”位，（换言之，若密钥中对应字母是A，则后移0位；若密钥中对应字母是 B，则后移1位，依此类推）：

<pre>
明文 ATTACKATDAWN
密钥 LEMONLEMONLE
密文 LXFOPVEFRNHR
</pre>

以 C 语言实现的话：

```c
/* Assume ASCII */

char
encrypt_char(char c_plaintext, char c_key)
{
    return (c_plaintext - 'A' + (c_key - 'A')) % 26 + 'A';
}

/* Assume `out` has enough capacity to hold ciphertext */
void
encrypt(char *out, const char *plaintext, const char *key)
{
    size_t key_size = strlen(key), plaintext_size = strlen(plaintext);

    for (size_t i = 0; i < plaintext_size; ++i) {
        out[i] = encrypt_char(plaintext[i], key[i % key_size]);
    }

    out[plaintext_size] = '\0';
}
```

花点时间理解下这东西。好了吗？你能想出破解方法吗？

想不出来也没关系，毕竟这东西发明出来以后花了三百年才被破解。不过如果你还不想太早放弃的话，我可以给点提示：我们可以先假定密钥长度已知。

下有答案，不想被糊一脸的话别急着下滑。

---
## 维吉尼亚密码的破解

假定密钥长度已知（例如，在刚才的例子里密钥长度是5），我们可以先把密文按照密钥长度分组。比如上例中，我们可以每五个字符分一组：

<pre>
LXFOP
VEFRN
HR
</pre>

然后我们将密文竖着看。注意到什么了吗？

没错，每个竖行都是用同一个字母加密的，故而位移相同。也就是说，每一个竖行都是一串经过凯撒加密的密文。此时破解方法已经呼之欲出了：我们可以对每个竖行分别应用一次针对凯撒加密的攻击，然后即可反推出密钥。

如果密钥长度未知呢？那也不难，我们只需要先假定密钥长度为1，进行攻击尝试；若无法得到有意义的明文，则再假定密钥长度为2，进行攻击尝试，依次穷举下去，直到我们得到有意义的密文。在仅有纸笔的时代密钥长度通常并不长，所以这个过程其实没有想象得那么耗时。

惊人地简单，是不是？

---

到这里我们可以先休息一下，因为接下来我们要介绍的东西值得单独分出一篇博文：转子加密机。这一类加密机中最著名的恐怕便是二战时纳粹德国使用的 Enigma 密码机了。尽管与之相关的神话数不胜数，但我将要演示的，其实是 Enigma 以如今的眼光来看，安全性到底低到什么程度。

下一话，Enigma 之死！